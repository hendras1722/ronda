<template>
  <h1 class="text-2xl font-extrabold text-center">Premium Ronda</h1>
  <p class="text-xl font-bold text-center mt-5">
    Kamu akan mendapatkan fitur premium yang akan mendukung ronda kampung kamu
  </p>

  <div class="px-32 my-10">
    <MSATable :rows="items" :columns="columns">
      <template #benefit-data="{ row }">
        <span class="text-black">{{ row.benefit }}</span>
      </template>
      <template #free-data="{ row }">
        <span class="font-extrabold text-black">{{ row.free }}</span>
      </template>
      <template #premium-data="{ row }">
        <span class="font-extrabold text-black">{{ row.premium }}</span>
      </template>
    </MSATable>
  </div>
  <div v-if="transaction.length > 0">
    <div
      v-for="(item, index) in transaction"
      :key="'transaction' + index"
      class="text-center"
    >
      <div v-if="item.status === 'pending'">
        <span class="font-extrabold text-3xl">
          Pembayaran Via
          {{ String(item.details.data.va_numbers[0].bank).toUpperCase() }}
        </span>
        <div class="text-2xl my-5 italic underline">
          {{ item.details.data.va_numbers[0].va_number }}
          <UIcon name="i-heroicons-square-2-stack-16-solid" class="ml-2 mt-2" />
        </div>
      </div>
      <UButton
        v-if="item.status === 'pending'"
        size="lg"
        variant="solid"
        color="green"
        @click="handleCheckStatus(item.orderId.id)"
      >
        Cek Status
      </UButton>

      <div v-if="item.status && item.status === 'expire'">
        <div class="text-center mb-5 font-extrabold text-xl">
          Pembayaran Belum Di Bayar
        </div>
        <UButton
          size="lg"
          class="mb-5"
          @click="handleSnap(item.orderId.id)"
          variant="solid"
          color="blue"
        >
          Aktifkan Premium
        </UButton>
      </div>
    </div>
  </div>
  <div v-if="successTransaction" class="text-center text-2xl font-bold">
    Selamat Ronda Anda Telah Premium
  </div>
  <div v-if="!successTransaction && transaction.length < 1" class="text-center">
    <UButton size="lg" variant="solid" color="blue" @click="handleSnap">
      Dapatkan Premium
    </UButton>
  </div>
</template>

<script setup lang="ts">
interface CustomWindow extends Window {
  snap: any // You can replace 'any' with a more specific type if available
}

declare let window: CustomWindow

const columns = [
  {
    key: 'benefit',
    label: 'Yang Kamu Dapatkan',
  },
  {
    key: 'free',
    label: 'Free',
  },
  {
    key: 'premium',
    label: 'Premium',
  },
]

const items = [
  {
    benefit: 'Anggota',
    free: 'Min 5 atau Max Anggota Terakhir Di Atas 5',
    premium: 'Unlimited',
  },
  {
    benefit: 'Catatan Iuran',
    free: 'Min 5 tau Max Anggota Terakhir Di Atas 5',
    premium: 'Unlimited',
  },
  {
    benefit: 'Ronda Jimpitan & Jadwal',
    free: 'Tidak',
    premium: 'Ya',
  },
  {
    benefit: 'Jimpitan Landing',
    free: 'Tidak',
    premium: 'Ya',
  },
]

interface history {
  created_at: string
  gross_amount: string
  id_complex: string
  id: string
}

// Generated by https://quicktype.io

interface Transaction {
  orderId: OrderID
  status: string
  details: Details
}

interface Details {
  data: Data
}

interface Data {
  status_code: string
  transaction_id: string
  gross_amount: string
  currency: string
  order_id: string
  payment_type: string
  signature_key: string
  transaction_status: string
  fraud_status: string
  status_message: string
  merchant_id: string
  va_numbers: VaNumber[]
  payment_amounts: any[]
  transaction_time: string
  expiry_time: string
}

interface VaNumber {
  bank: string
  va_number: string
}

interface OrderID {
  created_at: string
  gross_amount: string
  id_complex: string
  id: string
}

const transaction = ref<Transaction[]>([])
const successTransaction = ref(false)

async function checkStatus(orderId: string) {
  return useFetch<{ data: Data }>('/api/payment', {
    query: {
      token: orderId,
    },
    lazy: true,
  })
}

async function handleCheckStatus(e: string) {
  const { data } = await useFetch<{ data: any[] }>('/api/history')
  if (data.value?.data && data.value?.data.length > 0) {
    const res = (await checkMultipleTransactionStatuses(
      data.value?.data
    )) as Transaction[]
    console.log(res[0])
    if (res?.[0]?.status === 'expire') {
      transaction.value = res
      return
    }
    if (res?.[0]?.status === 'settlement') {
      successTransaction.value = true
      return
    }
  }
}

async function checkMultipleTransactionStatuses(orderIds: any[]) {
  const promises = orderIds.map((orderId) => {
    return checkStatus(orderId.id)
      .then((response: any) => ({
        orderId: orderId,
        status: response.data.value?.data.transaction_status,
        details: response.data.value,
      }))
      .catch((error) => ({
        orderId: orderId.id,
        error: error.message,
      }))
  })

  try {
    const results = await Promise.all(promises)
    return results
  } catch (error) {
    console.error('Error fetching transaction statuses:', error)
    // throw error
  }
}

async function getData(e?: string) {
  transaction.value = []
  const { data } = await useFetch<{ data: any[] }>('/api/history')

  if (data.value?.data && data.value?.data.length > 0) {
    const res = (await checkMultipleTransactionStatuses(
      data.value?.data
    )) as Transaction[]
    console.log(e, 'inie')
    if (e && ['error'].includes(e) && res.length > 0) {
      $fetch('/api/history', {
        method: 'DELETE',
        query: {
          id: data.value?.data[0].id,
        },
      })
    }
    if (res?.[0]?.status === 'settlement') {
      successTransaction.value = true
      return
    }

    if (res?.[0]?.status === 'expire') {
      successTransaction.value = false
      transaction.value = res
      return
    }
    successTransaction.value = false
    transaction.value = res
  }
}
getData()

function snapMidtrans(e: string) {
  const snapSrcUrl = 'https://app.sandbox.midtrans.com/snap/snap.js'
  const myMidtransClientKey = 'SB-Mid-client-4N27CUKGl5kIUoKs' //change this according to your client-key

  const script = document.createElement('script')
  script.src = snapSrcUrl
  script.setAttribute('data-client-key', myMidtransClientKey)
  script.async = true
  document.body.appendChild(script)
  const i = setTimeout(() => {
    window.snap.pay(e, {
      onSuccess: function (result: any) {
        /* You may add your own implementation here */
        // alert('payment success!')
        console.log(result)
      },
      onPending: function (result: any) {
        /* You may add your own implementation here */
        // alert('wating your payment!')
        getData()
        console.log(result)
      },
      onError: function (result: any) {
        /* You may add your own implementation here */
        // alert('payment failed!')
        console.log(result)
        getData('error')
      },
      onClose: function () {
        /* You may add your own implementation here */
        // alert('you closed the popup without finishing the payment')
        // $fetch('/api/history', {
        //   method: 'DELETE',
        //   query: {
        //     id: e,
        //   },
        // })
        getData()
      },
    })
    clearTimeout(i)
  }, 1000)
}

async function handleSnap(e?: string) {
  const history = await $fetch<{ data: history[] }>('/api/history', {
    method: 'POST',
    body: {
      gross_amount: '22000',
      id_complex: 'd4843528-fdc6-426a-953d-90dafca289a2',
    },
  })

  // if (transaction.value.length > 0) {
  //   $fetch('/api/history', {
  //     method: 'DELETE',
  //     query: {
  //       id: e,
  //     },
  //   })
  // }

  if (history) {
    const { data } = await useFetch<{ data: string }>('/api/payment', {
      method: 'POST',
      body: {
        transaction_details: {
          order_id: history.data[0].id,
          gross_amount: history.data[0].gross_amount,
        },
        credit_card: {
          secure: true,
        },
      },
    })
    if (data.value?.data) {
      await snapMidtrans(data.value.data)
    } else {
      console.error('Transaction data is undefined')
    }
  }
}
onMounted(() => {})
</script>

<style scoped></style>
